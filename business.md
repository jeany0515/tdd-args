我们经常会遇到需要解析命令行参数的场景。如果没有趁手的工具，我们可以自己写一个，自己想办法处理传给main函数的命令行参数。我们期望能把传递进来的命令行字符串参数，转换成方便使用的结构化数据。

传递给程序的命令行参数包含两个部分：
1. flag: 是一个字符，在传入给程序时必须前置一个短横线，flag后可以有0个或1个value
2. value: 跟在flag后的具体值

我们需要一个schema来指定期望接受到的参数格式，并且解析上述这种命令行参数。
schema会指定flag和value的类型。当程序将参数的字符串传递给程序后，程序会首先检查传入的参数是否符合schema的要求。

例如：
程序希望的传入命令行参数如下：
-l true -p 8080 -d /usr/logs

那么对应的schema要求应为：
* 参数可以有三种flag: l, p, d
* l的value类型为boolean
* p的value类型为整数
* d的value类型为string


1.假如在命令行参数中，schema支持的flag没有对应的value，那么value值为默认值。例如布尔值的默认值为false，数值的默认值为0，字符串的默认值为”"。

2. 假如在命令行参数中，没有传入支持的flag，在使用该flag时也使用其默认值。

3. 假如传入的命令行参数不符合schema的规定，我们必须给出友好的错误提示以告知到底什么出了问题。

4. Schema的falg不能重复，重复会报错。

5. 整个字符串前后可以有空格，比如”    -l  true    ”

6. 参数之间不用空格分割视为非法，比如-p-d

7. 不允许输入重复flag

8. value不能以-开头，如果以-开头，视作另一个参数的开始

9. -与flag之间加空格报错, value中间有空格报错

10. flag与value之间，flag之间可以有多空格

